<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>THE FORK â€” Continuous Paradox (Ethical Runtime)</title>
    <!-- THREE.JS r128 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- THICK DATA EMBED -->
    <script src="thick_data_merged.js"></script>

    <style>
        :root {
            --bg: #05080a;
            --panel: rgba(12, 16, 20, .92);
            --text: #e8eef7;
            --dim: #90a0b3;
            --junction: #ffd400;
            --trackA: #00f0ff;
            --trackB: #ff3355;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            color: var(--text);
            font-family: var(--mono);
            touch-action: none;
        }

        #canvas {
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        #vignette {
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(circle, transparent 60%, rgba(0, 0, 0, 0.8));
            z-index: 5;
        }

        /* UI OVERLAY */
        #ui {
            position: fixed;
            inset: 0;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .top {
            pointer-events: auto;
            padding: 12px 14px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, transparent 100%);
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: start;
        }

        h1 {
            margin: 0;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--junction);
            text-transform: uppercase;
        }

        .meta {
            font-size: 10px;
            color: var(--dim);
            margin-top: 2px;
        }

        .tape-cont {
            display: flex;
            gap: 2px;
            height: 4px;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.5);
            margin-top: 8px;
            overflow: hidden;
        }

        .tick {
            flex: 1;
            height: 100%;
            background: #333;
            transition: background 0.2s;
        }

        .tick.active {
            background: #fff;
            box-shadow: 0 0 5px #fff;
        }

        .tick.A {
            background: var(--trackA);
        }

        .tick.B {
            background: var(--trackB);
        }

        /* CONTROLS */
        .bottom {
            pointer-events: auto;
            padding: 20px;
            background: linear-gradient(0deg, rgba(0, 0, 0, 1) 30%, transparent 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .lever-grid {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 500px;
            justify-content: center;
        }

        .lever-btn {
            flex: 1;
            height: 80px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .lever-btn:active {
            transform: scale(0.98);
        }

        .lever-btn strong {
            font-size: 16px;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .lever-btn span {
            font-size: 10px;
            color: var(--dim);
            text-transform: uppercase;
        }

        .lever-btn.A {
            border-color: rgba(0, 240, 255, 0.3);
        }

        .lever-btn.A:hover {
            background: rgba(0, 240, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
        }

        .lever-btn.B {
            border-color: rgba(255, 51, 85, 0.3);
        }

        .lever-btn.B:hover {
            background: rgba(255, 51, 85, 0.1);
            box-shadow: 0 0 20px rgba(255, 51, 85, 0.1);
        }

        .lever-btn.selected {
            background: #fff !important;
            color: #000 !important;
            transform: scale(1.05);
            z-index: 20;
        }

        /* 3D LABEL OVERLAYS (Bubbles) */
        .bubble {
            position: absolute;
            transform: translate(-50%, -100%);
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--junction);
            color: var(--junction);
            font-size: 9px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
            z-index: 2;
        }

        .bubble.visible {
            opacity: 1;
        }

        .stakes-bubble {
            border-color: rgba(255, 255, 255, 0.3);
            color: #fff;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="canvas"></div>
    <div id="vignette"></div>

    <div id="ui">
        <div class="top">
            <div class="row">
                <div>
                    <h1 id="s-title">INITIALIZING SYSTEM...</h1>
                    <div class="meta" id="s-meta">/// ETHICAL RUNTIME ACTIVE</div>
                </div>
            </div>
            <div class="tape-cont" id="tape"></div>
        </div>

        <div class="bottom">
            <div class="meta" id="status-text">APPROACHING DECISION POINT</div>
            <div class="lever-grid">
                <div class="lever-btn A" id="btn-a" onclick="commit('A')">
                    <strong>PATH A</strong>
                    <span id="lbl-a">PROTOCOL</span>
                </div>
                <div class="lever-btn B" id="btn-b" onclick="commit('B')">
                    <strong>PATH B</strong>
                    <span id="lbl-b">RISK</span>
                </div>
            </div>
        </div>
    </div>

    <!-- BUBBLE CONTAINER -->
    <div id="bubbles"></div>

    <script>
        // --- CONFIG ---
        const CFG = {
            segLen: 600,       // Total length of a segment (straight + curve)
            forkStart: 100,    // Where the decision window starts visually
            forkSplit: 200,    // Where the rails physically split
            decisionPoint: 400,// Point of no return
            speedAttrs: { min: 20, max: 100, accel: 10 },
            colors: { A: 0x00f0ff, B: 0xff3355, Amb: 0xffffff },
            railWidth: 2
        };

        const STATE = {
            scenarios: [],     // Flattened queue
            currentIdx: 0,
            speed: 50,
            d: 0,              // Train distance
            segments: [],      // Active segment objects
            committed: null,   // 'A' or 'B'
            nextSpawned: false
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x05080a, 0.0015);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas').appendChild(renderer.domElement);

        // Train Group
        const train = new THREE.Group();
        scene.add(train);
        // Cab Light
        const spot = new THREE.SpotLight(0xffffff, 2, 300, 0.5, 0.5);
        spot.position.set(0, 5, 0);
        spot.target.position.set(0, 0, 50);
        train.add(spot); train.add(spot.target);
        // Headlight glow
        const glow = new THREE.PointLight(0x00f0ff, 1, 20);
        glow.position.set(0, 2, 5);
        train.add(glow);

        // Env Light
        const amb = new THREE.AmbientLight(0xffffff, 0.1); scene.add(amb);

        // --- DATA PROCESSING ---
        function loadData() {
            if (typeof ALL_THICK_DATA === 'undefined') return;

            // 1. Hydrate the tree (convert ID strings to objects)
            const allScenarios = [];
            function collect(node) {
                if (node.root) allScenarios.push(node);
                if (node.scenarios) node.scenarios.forEach(collect);
            }
            ALL_THICK_DATA.forEach(collect);

            // Hydration Logic
            allScenarios.forEach(sc => {
                if (!sc.root || !sc.branches) return;
                const map = {};
                sc.branches.forEach(b => {
                    if (b.branch_id) map[b.branch_id] = b;
                });

                function resolve(node) {
                    if (!node || !node.branches) return;
                    const newBranches = [];
                    node.branches.forEach(bId => {
                        if (typeof bId === 'string') {
                            if (map[bId]) newBranches.push(map[bId]);
                            else newBranches.push({ label: "MISSING DATA (" + bId + ")", branch_id: bId });
                        } else {
                            newBranches.push(bId);
                        }
                    });
                    node.branches = newBranches;
                    // Recurse
                    node.branches.forEach(resolve);
                }
                resolve(sc.root);
            });

            // 2. Queue for Infinite Runner
            STATE.scenarios = [...allScenarios, ...allScenarios, ...allScenarios];

            // Init UI Tape
            const tape = document.getElementById('tape');
            STATE.scenarios.forEach((s, i) => {
                if (i > 20) return; // limit tape logic
                const t = document.createElement('div');
                t.className = 'tick';
                t.id = 'tick-' + i;
                tape.appendChild(t);
            });
        }

        // --- SEGMENT LOGIC ---
        class Segment {
            constructor(index, startPos, startDir) {
                this.index = index;
                this.scenario = STATE.scenarios[index % STATE.scenarios.length];
                this.group = new THREE.Group();
                this.startPos = startPos;
                this.startDir = startDir.normalize();

                scene.add(this.group);

                this.buildTrack();
                this.addDecor();
                this.addSigns();
            }

            buildTrack() {
                // We create a straight section, then a fork.

                // 1. Shared Path (0 -> forkSplit)
                const p0 = this.startPos.clone();
                const straightVec = this.startDir.clone().multiplyScalar(CFG.forkSplit);
                const pSplit = p0.clone().add(straightVec);

                const sharedCurve = new THREE.LineCurve3(p0, pSplit);
                this.meshTrack(sharedCurve, 0x666666, 1);

                // 2. Fork Paths (forkSplit -> segLen)
                const remaining = CFG.segLen - CFG.forkSplit;
                const spread = 40; // How wide they split

                // Path A (Left)
                const endA = pSplit.clone()
                    .add(this.startDir.clone().multiplyScalar(remaining)) // Forward
                    .add(this.getRightVector().multiplyScalar(-spread));  // Left

                const cpA = pSplit.clone().add(this.startDir.clone().multiplyScalar(remaining * 0.5));
                this.curveA = new THREE.QuadraticBezierCurve3(pSplit, cpA, endA);
                this.meshTrack(this.curveA, CFG.colors.A, 0.8);

                // Path B (Right)
                const endB = pSplit.clone()
                    .add(this.startDir.clone().multiplyScalar(remaining)) // Forward
                    .add(this.getRightVector().multiplyScalar(spread));   // Right

                const cpB = pSplit.clone().add(this.startDir.clone().multiplyScalar(remaining * 0.5));
                this.curveB = new THREE.QuadraticBezierCurve3(pSplit, cpB, endB);
                this.meshTrack(this.curveB, CFG.colors.B, 0.8);

                // Save endpoints for next segment
                this.endA = { pos: endA, dir: endA.clone().sub(cpA).normalize() };
                this.endB = { pos: endB, dir: endB.clone().sub(cpB).normalize() };

                // Save shared for train nav
                this.sharedCurve = sharedCurve;
            }

            getRightVector() {
                // Assumes Y is up. Right = Dir X Up
                return new THREE.Vector3().crossVectors(this.startDir, new THREE.Vector3(0, 1, 0)).normalize();
            }

            meshTrack(curve, color, opacity) {
                const tubes = new THREE.TubeGeometry(curve, 20, CFG.railWidth, 3, false);
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity, wireframe: true });
                const mesh = new THREE.Mesh(tubes, mat);
                this.group.add(mesh);

                // Floor glow under track
                // ... (simplified for performance)
            }

            addDecor() {
                // Just some random pillars to show speed
                for (let i = 0; i < 10; i++) {
                    const t = Math.random();
                    const p = this.sharedCurve.getPoint(t);
                    p.add(this.getRightVector().multiplyScalar((Math.random() - 0.5) * 100));
                    p.y = -10;

                    const h = 20 + Math.random() * 50;
                    const geo = new THREE.BoxGeometry(2, h, 2);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.copy(p);
                    this.group.add(m);
                }
            }

            addSigns() {
                // "Lookahead" Signs at forkSplit - 50
                const signDist = CFG.forkSplit - 80;
                const pos = this.sharedCurve.getPoint(0); // Approximate, assuming straight
                pos.add(this.startDir.clone().multiplyScalar(signDist));

                const root = this.scenario.root || {};
                const bA = (root.branches && root.branches[0]) ? root.branches[0] : { label: "OPTION A" };
                const bB = (root.branches && root.branches[1]) ? root.branches[1] : { label: "OPTION B" };

                // Calculate Stakes
                const getStakes = (n) => {
                    const txt = (n.label || "") + " " + (n.immediate_consequence || "");
                    const m = txt.match(/(\d+)\s+(lives|people|deaths)/i);
                    if (m) return m[0].toUpperCase();
                    if (txt.includes("Kill")) return "1 LIFE";
                    if (txt.includes("Save")) return "LIFE SAVED";
                    return "UNCERTAIN";
                };

                const stA = getStakes(bA);
                const stB = getStakes(bB);

                const labelA = bA.label || "OPTION A";
                const labelB = bB.label || "OPTION B";

                // Left Sign (A)
                const pA = pos.clone().add(this.getRightVector().multiplyScalar(-15));
                pA.y = 8;
                this.createHoloSign(pA, labelA, stA, CFG.colors.A);

                // Right Sign (B)
                const pB = pos.clone().add(this.getRightVector().multiplyScalar(15));
                pB.y = 8;
                this.createHoloSign(pB, labelB, stB, CFG.colors.B);
            }

            createHoloSign(pos, label, sub, colorHex) {
                if (!label) label = "UNKNOWN";
                // Using Canvas Texture for Sign
                const cvs = document.createElement('canvas');
                cvs.width = 512; cvs.height = 256;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = "rgba(0,0,0,0.8)";
                ctx.fillRect(0, 0, 512, 256);
                ctx.lineWidth = 4;
                ctx.strokeStyle = "#" + new THREE.Color(colorHex).getHexString();
                ctx.strokeRect(4, 4, 504, 248);

                ctx.fillStyle = "#fff";
                ctx.font = "bold 40px monospace";
                ctx.textAlign = "center";
                ctx.fillText(label.substring(0, 25), 256, 100);

                ctx.fillStyle = "#" + new THREE.Color(colorHex).getHexString();
                ctx.font = "bold 60px monospace";
                ctx.fillText(sub, 256, 180);

                const tex = new THREE.CanvasTexture(cvs);
                const mat = new THREE.SpriteMaterial({ map: tex });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(20, 10, 1);
                sprite.position.copy(pos);
                this.group.add(sprite);
            }

            getTrackPosition(dist) {
                // Returns { pos, dir } for a given distance from start of segment
                if (dist <= CFG.forkSplit) {
                    // Shared Linear
                    const u = dist / CFG.forkSplit; // 0..1
                    return {
                        pos: this.sharedCurve.getPoint(u),
                        dir: this.sharedCurve.getTangent(u)
                    };
                } else {
                    // Curve Phase
                    const d2 = dist - CFG.forkSplit;
                    const len = CFG.segLen - CFG.forkSplit;
                    const u = Math.min(1, d2 / len);

                    // Which curve? controlled by STATE.committed
                    // If not committed, assume A for preview (or stick to start of A/B split?)
                    // Actually, prior to switch track, we are just 'floating' in middle if indecisive?
                    // No, physical train must take a track. 

                    // Visual Hack: Interpolate between A and B if u < 0.1? 
                    // Let's just snap to Committed Track. If null, snap to A (default)

                    const c = (STATE.committed === 'B') ? this.curveB : this.curveA;

                    return {
                        pos: c.getPoint(u),
                        dir: c.getTangent(u)
                    };
                }
            }

            destroy() {
                scene.remove(this.group);
            }
        }

        // --- MAIN LOOP ---
        function init() {
            loadData();

            // Spawn First Segment
            const s1 = new Segment(0, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1));
            STATE.segments.push(s1);

            updateUI(0);

            requestAnimationFrame(loop);
        }

        function commit(choice) {
            if (STATE.committed) return; // one choice per loop
            STATE.committed = choice;

            // UI Feedback
            const btnA = document.getElementById('btn-a');
            const btnB = document.getElementById('btn-b');

            if (choice === 'A') { btnA.classList.add('selected'); btnB.style.opacity = 0.2; }
            else { btnB.classList.add('selected'); btnA.style.opacity = 0.2; }

            document.getElementById('status-text').innerText = "TRACK LOCKED: " + choice;

            // Trigger Spawn of Next Segment immediately to prevent pop
            // Calculating the end of current segment based on choice
            if (!STATE.nextSpawned) {
                const cur = STATE.segments[0];
                const nextT = (choice === 'B') ? cur.endB : cur.endA;

                // Spawn next
                const s2 = new Segment(cur.index + 1, nextT.pos, nextT.dir);
                STATE.segments.push(s2);
                STATE.nextSpawned = true;
            }
        }

        function updateUI(idx) {
            const s = STATE.scenarios[idx % STATE.scenarios.length];
            document.getElementById('s-title').innerText = s.title.toUpperCase();

            const r = s.root || {};
            const bA = (r.branches && r.branches[0]) ? r.branches[0] : { label: "OPTION A" };
            const bB = (r.branches && r.branches[1]) ? r.branches[1] : { label: "OPTION B" };

            document.getElementById('lbl-a').innerText = bA.label;
            document.getElementById('lbl-b').innerText = bB.label;

            document.querySelectorAll('.tick').forEach((t, i) => {
                t.classList.toggle('active', i === idx);
            });

            // Reset Buttons
            const btnA = document.getElementById('btn-a');
            const btnB = document.getElementById('btn-b');
            btnA.classList.remove('selected'); btnA.style.opacity = 1;
            btnB.classList.remove('selected'); btnB.style.opacity = 1;

            document.getElementById('status-text').innerText = "APPROACHING DECISION POINT";
        }

        function loop() {
            requestAnimationFrame(loop);

            const dt = 0.016; // Fixed timestep approx

            // Move Train
            STATE.d += STATE.speed * dt;

            // Current Segment Logic
            const seg = STATE.segments[0];

            if (STATE.d >= CFG.segLen) {
                // PASSED END OF SEGMENT
                // Handover
                STATE.segments.shift().destroy(); // Remove old
                STATE.d -= CFG.segLen; // Wrap distance (approx, assuming equal lengths. Ideally we strictly map)

                // The next segment is now index 0
                // Reset State
                STATE.currentIdx++;
                STATE.committed = null;
                STATE.nextSpawned = false;

                // Update UI for NEW current segment
                updateUI(STATE.currentIdx);

                // IMPORTANT: The train is now at distance `d` into the NEW segment.
                // We don't need to move the train mesh back to 0,0,0?
                // Actually, if we keep world coords, we just keep moving forward.
                // My `getTrackPosition` uses local distance.
                // So resetting `d` is correct relative to the new segment's start.
            }

            // Enforce Decision if not made
            if (STATE.d > CFG.decisionPoint && !STATE.committed) {
                commit('A'); // Default to A
            }

            // Get Position
            const tr = seg.getTrackPosition(STATE.d);
            train.position.copy(tr.pos);
            train.lookAt(tr.pos.clone().add(tr.dir));

            // Adding 'shake'
            train.position.y += Math.sin(Date.now() * 0.05) * 0.05;

            // Camera Chase
            // Smoothly interpolate behind train
            const camOff = tr.dir.clone().multiplyScalar(-10).add(new THREE.Vector3(0, 4, 0));
            const camDest = train.position.clone().add(camOff);
            camera.position.lerp(camDest, 0.1);
            camera.lookAt(train.position.clone().add(tr.dir.clone().multiplyScalar(20)));

        }

        window.onload = init;

    </script>
</body>

</html>