<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: The Smallest Possible World (Train Sequence)</title>
    <style>
        :root {
            --bg-color: #000203;
            --font-mono: 'Courier New', Courier, monospace;
            --font-sans: 'Inter', system-ui, sans-serif;
            --primary: #00ff41;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: #ccc;
            font-family: var(--font-sans);
            overflow: hidden;
            height: 100vh;
        }

        #viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #hud-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 20%, transparent 80%, rgba(0, 0, 0, 0.8) 100%);
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-family: var(--font-mono);
            font-size: 14px;
            color: #00ff41;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        .hud-bottom {
            padding: 40px;
            text-align: center;
        }

        .beat-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .beat-desc {
            font-size: 16px;
            color: #aaa;
            max-width: 600px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid #333;
        }

        #controls {
            pointer-events: auto;
        }

        .btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 10px 20px;
            font-family: var(--font-mono);
            cursor: pointer;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(0, 255, 65, 0.3);
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>

<body>

    <div id="viewport"></div>

    <div id="hud-layer">
        <div class="hud-top">
            <div id="sys-name">GREMLIN_ARCHIVES // ACT_1</div>
            <div>STATUS: <span id="status-ind">CALIBRATING</span></div>
        </div>

        <div class="hud-bottom">
            <div id="beat-display">
                <div class="beat-title" id="beat-title">--</div>
                <div class="beat-desc" id="beat-desc">--</div>
            </div>
            <div id="controls" style="margin-top: 20px;">
                <button class="btn" id="btn-next">NEXT BEAT [SPACE]</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. DATA (ACT 1: The Smallest Possible World) ---
        const ACT_DATA = [
            { id: "B1", title: "Scale: The Cube", desc: "A single white cube on an infinite grid. The origin point.", type: "CUBE" },
            { id: "B2", title: "Tool: The Cursor", desc: "A cursor appears. It highlights the cube. Selection is the first act of violence.", type: "CURSOR" },
            { id: "B3", title: "Act: The Split", desc: "The cube divides. 1 becomes 2. The pop sound is satisfying.", type: "SPLIT" },
            { id: "B4", title: "Context: The Grid", desc: "The grid extends to the horizon. A promise of infinite expansion.", type: "GRID" },
            { id: "B5", title: "Constraint: Gravity", desc: "The blocks fall. Physics is introduced as a limitation.", type: "GRAVITY" },
            { id: "B6", title: "Motif: The Click", desc: "Sound becomes reward. Snap. Fit. Lock.", type: "CLICK" },
            { id: "B7", title: "Scale: The House", desc: "Simple structure. Four walls. A roof. Shelter logic.", type: "HOUSE" },
            { id: "B8", title: "Scene: The Village", desc: "Multiple houses. Roads. The first neighbor problem.", type: "VILLAGE" },
            { id: "B9", title: "Contradiction: Edge", desc: "The world ends at the cliff. You cannot build past X=100.", type: "EDGE" },
            { id: "B10", title: "Pressure: Night", desc: "Light fades. Hostile shapes appear. Fear drives construction.", type: "NIGHT" },
            { id: "B11", title: "Motif: The Torch", desc: "Light is safety. You place it to survive.", type: "TORCH" },
            { id: "B12", title: "Scene: The Fortress", desc: "Walls grow high. Windows shrink. Paranoia architecture.", type: "FORTRESS" },
            { id: "B13", title: "Scale: The City", desc: "Towers rise. The grid is full. No space left.", type: "CITY" },
            { id: "B14", title: "Failure: The Lag", desc: "Frames drop. The simulation slows. Too many entities.", type: "LAG" },
            { id: "B15", title: "Act Button", desc: "Promise: A bigger server. Threat: You are not the admin.", type: "BUTTON" }
        ];

        let currentBeat = -1;

        // --- 2. THREE.JS ENGINE (TRAIN CHASSIS) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('viewport').appendChild(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // GROUND
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x111111, depthWrite: false }));
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);
        const grid = new THREE.GridHelper(2000, 200, 0x222222, 0x111111);
        scene.add(grid);

        // TRACKS (Infinite Straight for this Act)
        // We will move the "World" past the "Train" to simulate movement, or move the Train.
        // Let's move the Train.
        const TRAIN_GROUP = new THREE.Group();
        scene.add(TRAIN_GROUP);

        // Train Body (Simulated Cab reused from Ch2)
        const cab = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 6), new THREE.MeshStandardMaterial({ color: 0x202020, roughness: 0.7 }));
        cab.position.y = 2.5;
        TRAIN_GROUP.add(cab);

        // Window Frame
        const windowFrame = new THREE.Mesh(new THREE.BoxGeometry(3.8, 2, 0.1), new THREE.MeshStandardMaterial({ color: 0x000000 }));
        windowFrame.position.set(0, 3, 3); // Front window
        // Keep it open? Or glass? Let's make it a frame.
        // Actually, let's just put the camera on the nose of the train.

        camera.position.set(0, 4, -2); // Behind train? No, on front.
        // Let's do "Cockpit View"
        camera.position.set(0, 3.5, 2.5);
        camera.lookAt(0, 2.5, 20);
        TRAIN_GROUP.add(camera);

        // Add "Dashboard"
        const dash = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 1), new THREE.MeshBasicMaterial({ color: 0x001100 }));
        dash.position.set(0, 2.5, 3);
        TRAIN_GROUP.add(dash);

        // Rails
        const railGeo = new THREE.BoxGeometry(0.2, 0.2, 1000);
        const railMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
        const leftRail = new THREE.Mesh(railGeo, railMat); leftRail.position.set(-1.5, 0.1, 500);
        const rightRail = new THREE.Mesh(railGeo, railMat); rightRail.position.set(1.5, 0.1, 500);
        scene.add(leftRail); scene.add(rightRail);

        // --- 3. SPOTLIGHT & EXHIBITS ---
        const focusSpot = new THREE.SpotLight(0xffffff, 2, 200, 0.3, 0.5, 1);
        focusSpot.position.set(0, 10, 0); // Relative to Train
        focusSpot.castShadow = true;
        focusSpot.target.position.set(0, 0, 50);
        TRAIN_GROUP.add(focusSpot);
        scene.add(focusSpot.target); // Target must be in scene

        const BEAT_SPACING = 100;
        const EXHIBITS = [];

        function createExhibits() {
            ACT_DATA.forEach((beat, i) => {
                const zPos = (i + 1) * BEAT_SPACING;
                const group = new THREE.Group();
                group.position.set(0, 0, zPos);

                // Base Platform
                const platform = new THREE.Mesh(new THREE.CylinderGeometry(14, 14, 0.5, 32), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                platform.position.y = 0.25;
                group.add(platform);

                // BESPOKE CONTENT GENERATION
                let content = new THREE.Group();
                const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const matOrange = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
                const matRed = new THREE.MeshStandardMaterial({ color: 0xff3333 });
                const matGray = new THREE.MeshStandardMaterial({ color: 0x888888 });

                if (beat.type === "CUBE") {
                    content.add(new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), matWhite));
                    content.position.y = 2;
                }
                else if (beat.type === "CURSOR") {
                    const cube = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({ color: 0x00ff41, transparent: true, opacity: 0.5 }));
                    const cursor = new THREE.Mesh(new THREE.ConeGeometry(1, 4, 4), matWhite);
                    cursor.rotation.z = -Math.PI / 4;
                    cursor.position.set(2, 4, 0);
                    content.add(cube, cursor);
                    content.position.y = 2;
                }
                else if (beat.type === "SPLIT") {
                    const c1 = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), matWhite); c1.position.x = -1.5;
                    const c2 = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), matWhite); c2.position.x = 1.5;
                    content.add(c1, c2);
                    content.position.y = 2;
                }
                else if (beat.type === "GRID") {
                    const g = new THREE.GridHelper(30, 30, 0x00ff41, 0x004400);
                    content.add(g);
                }
                else if (beat.type === "GRAVITY") {
                    for (let k = 0; k < 8; k++) {
                        const b = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), matGray);
                        b.position.set((Math.random() - 0.5) * 6, 0.5, (Math.random() - 0.5) * 6);
                        b.rotation.set(Math.random(), Math.random(), Math.random());
                        content.add(b);
                    }
                }
                else if (beat.type === "CLICK") {
                    const a = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), matOrange); a.position.x = -1.1;
                    const b = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), matOrange); b.position.x = 1.1;
                    content.add(a, b);
                    content.position.y = 2;
                }
                else if (beat.type === "HOUSE") {
                    const h = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 3), matWhite);
                    const r = new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.5, 4), matRed);
                    r.position.y = 2; r.rotation.y = Math.PI / 4;
                    content.add(h, r);
                    content.position.y = 1.25;
                }
                else if (beat.type === "VILLAGE") {
                    const pos = [[-4, -2], [4, 2], [0, 0], [-3, 3], [3, -3]];
                    pos.forEach(p => {
                        const h = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1.5), matWhite);
                        h.position.set(p[0], 0, p[1]);
                        const r = new THREE.Mesh(new THREE.ConeGeometry(1.2, 0.8, 4), matRed);
                        r.position.set(p[0], 0.9, p[1]); r.rotation.y = Math.PI / 4;
                        content.add(h, r);
                    });
                    content.position.y = 1;
                }
                else if (beat.type === "EDGE") {
                    const wall = new THREE.Mesh(new THREE.BoxGeometry(0.5, 10, 20), new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true }));
                    content.add(wall);
                    content.position.y = 5;
                }
                else if (beat.type === "NIGHT") {
                    // Scary Eyes
                    const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                    eye1.position.set(-2, 3, 0);
                    const eye2 = eye1.clone(); eye2.position.set(2, 3, 0);
                    content.add(eye1, eye2);
                }
                else if (beat.type === "TORCH") {
                    const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
                    const flame = new THREE.PointLight(0xff6600, 3, 15);
                    flame.add(new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({ color: 0xffaa00 })));
                    flame.position.y = 1.5;
                    content.add(stick, flame);
                    content.position.y = 1.5;
                }
                else if (beat.type === "FORTRESS") {
                    const w1 = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 1), matGray); w1.position.z = -3.5;
                    const w2 = new THREE.Mesh(new THREE.BoxGeometry(8, 4, 1), matGray); w2.position.z = 3.5;
                    const w3 = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 8), matGray); w3.position.x = -3.5;
                    const w4 = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 8), matGray); w4.position.x = 3.5;
                    content.add(w1, w2, w3, w4);
                    content.position.y = 2;
                }
                else if (beat.type === "CITY") {
                    for (let k = 0; k < 15; k++) {
                        const h = 2 + Math.random() * 6;
                        const b = new THREE.Mesh(new THREE.BoxGeometry(1, h, 1), matWhite);
                        b.position.set((Math.random() - 0.5) * 8, h / 2, (Math.random() - 0.5) * 8);
                        content.add(b);
                    }
                }
                else if (beat.type === "LAG") {
                    for (let k = 0; k < 20; k++) {
                        const t = new THREE.Mesh(new THREE.TetrahedronGeometry(1), new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true }));
                        t.position.set((Math.random() - 0.5) * 10, Math.random() * 5, (Math.random() - 0.5) * 10);
                        content.add(t);
                    }
                }
                else if (beat.type === "BUTTON") {
                    const base = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 1), matGray);
                    const btn = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.5), matRed);
                    btn.position.y = 0.5;
                    content.add(base, btn);
                    content.position.y = 0.5;
                }
                else {
                    content.add(new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshStandardMaterial({ color: 0x00ff00, wireframe: true })));
                    content.position.y = 2;
                }

                group.add(content);
                scene.add(group);
                EXHIBITS.push({ group, type: beat.type, z: zPos });
            });
        }
        createExhibits();

        // --- 4. LOGIC ---
        let targetZ = 0;

        function nextBeat() {
            if (currentBeat < ACT_DATA.length - 1) {
                currentBeat++;
                const beat = ACT_DATA[currentBeat];

                // Update HUD
                document.getElementById('beat-title').innerText = beat.title;
                document.getElementById('beat-desc').innerText = beat.desc;
                document.getElementById('status-ind').innerText = `BEAT ${currentBeat + 1}/${ACT_DATA.length}`;

                // Set Train Target
                targetZ = (currentBeat + 1) * BEAT_SPACING - 20; // Stop 20 units before

                // Update Spotlight Target
                if (focusSpot && EXHIBITS[currentBeat]) {
                    focusSpot.target.position.copy(EXHIBITS[currentBeat].group.position);
                }

                // Trigger specific anims
                if (beat.type === "NIGHT") {
                    new TWEEN.Tween(hemiLight).to({ intensity: 0.1 }, 2000).start();
                    scene.background = new THREE.Color(0x000000);
                } else {
                    // Restore light if not night
                    if (hemiLight.intensity < 0.5) {
                        new TWEEN.Tween(hemiLight).to({ intensity: 0.6 }, 1000).start();
                        scene.background = new THREE.Color(0x050505);
                    }
                }
            } else {
                document.getElementById('beat-title').innerText = "ACT ONE COMPLETE";
                document.getElementById('beat-desc').innerText = "Approaching Chapter 6...";
            }
        }

        // --- ENO AUDIO ENGINE ---
        class EnoEngine {
            constructor() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();

                    // Master Gain
                    this.master = this.ctx.createGain();
                    this.master.gain.value = 0.4;
                    this.master.connect(this.ctx.destination);

                    // 1. CARRIER (The Train Hull)
                    // Low frequency sine wave that pitches up with speed
                    this.carrier = this.ctx.createOscillator();
                    this.carrier.type = 'sine';
                    this.carrier.frequency.value = 60;
                    this.carrierGain = this.ctx.createGain();
                    this.carrierGain.gain.value = 0;
                    this.carrier.connect(this.carrierGain).connect(this.master);
                    this.carrier.start();

                    // 2. TEXTURE (The Spark)
                    // High pass noise or complex wave for friction
                    this.texture = this.ctx.createOscillator();
                    this.texture.type = 'triangle';
                    this.texture.frequency.value = 120;
                    this.textureFilter = this.ctx.createBiquadFilter();
                    this.textureFilter.type = 'lowpass';
                    this.textureFilter.frequency.value = 400;
                    this.textureGain = this.ctx.createGain();
                    this.textureGain.gain.value = 0;

                    this.texture.connect(this.textureFilter).connect(this.textureGain).connect(this.master);
                    this.texture.start();

                } catch (e) {
                    console.warn("Audio Context Failed", e);
                }
            }

            update(speed, currentBeatType) {
                if (!this.ctx) return;

                const now = this.ctx.currentTime;

                // MAPPING 1: Speed -> Carrier Pitch & Vol
                // speed is approx 0 to 5
                const targetFreq = 50 + (speed * 20); // 50Hz to 150Hz
                this.carrier.frequency.setTargetAtTime(targetFreq, now, 0.1);

                // Volume ramps up with speed, but never total silence (maintain presence)
                const targetVol = Math.min(speed * 0.5, 0.6);
                this.carrierGain.gain.setTargetAtTime(targetVol, now, 0.2);

                // MAPPING 2: Beat Type -> Texture
                // When speed drops (arrival), the texture filter opens up to reveal "meaning"
                if (speed < 1.0) {
                    // Approaching or Stopped
                    // Create a "chord" or "texture" based on type
                    let harmonic = 2; // Octave
                    if (currentBeatType === "NIGHT") harmonic = 1.5; // Dissonant fifth
                    if (currentBeatType === "GRID") harmonic = 4; // High shimmer

                    this.texture.frequency.setTargetAtTime(targetFreq * harmonic, now, 0.5);
                    this.textureGain.gain.setTargetAtTime(0.1, now, 1.0); // Subtle presence
                    this.textureFilter.frequency.setTargetAtTime(1200, now, 2.0); // Open up filter slowly
                } else {
                    // Moving fast - texture clamped down
                    this.textureGain.gain.setTargetAtTime(0, now, 0.1);
                    this.textureFilter.frequency.setTargetAtTime(100, now, 0.1);
                }
            }

            triggerStationID(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain).connect(this.master);

                // Sound Palette
                if (type === "SPLIT") {
                    // "POP" - satisfying, short sine/triangle blip
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.5, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.3);
                } else if (type === "CUBE" || type === "CURSOR") {
                    // "PING" - high sine
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    osc.start(t);
                    osc.stop(t + 0.6);
                } else if (type === "NIGHT") {
                    // "DOOM" - Low saw drop
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 1.0);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.4, t + 0.1);
                    gain.gain.linearRampToValueAtTime(0, t + 1.0);
                    osc.start(t);
                    osc.stop(t + 1.1);
                } else {
                    // Generic "ARRIVAL" - soft bell
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, t);
                    osc.frequency.exponentialRampToValueAtTime(220, t + 0.5);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.2, t + 0.05);
                    gain.gain.linearRampToValueAtTime(0, t + 0.5);
                    osc.start(t);
                    osc.stop(t + 0.6);
                }
            }
        }

        const audio = new EnoEngine();

        // --- 5. LOOP ---
        let hasArrived = true;

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);

            // Move Train
            const dist = targetZ - TRAIN_GROUP.position.z;
            let currentSpeed = 0;

            if (Math.abs(dist) > 0.5) {
                currentSpeed = Math.max(0.1, dist * 0.05);
                TRAIN_GROUP.position.z += currentSpeed;
                hasArrived = false;
            } else {
                if (!hasArrived) {
                    hasArrived = true;
                    // ARRIVAL EVENT
                    const beat = ACT_DATA[currentBeat];
                    audio.triggerStationID(beat ? beat.type : 'NONE');
                }
            }

            // Audio Update
            // We need to know the 'next' beat type if we are moving towards it
            // Or the current one if we are there.
            const targetBeat = ACT_DATA[currentBeat]; // The one we are at or moving to
            audio.update(currentSpeed, targetBeat ? targetBeat.type : 'NONE');

            // Animate Exhibits
            EXHIBITS.forEach(ex => {
                ex.group.rotation.y += 0.005;
            });

            // Rails Loop
            leftRail.position.z = TRAIN_GROUP.position.z + 500;
            rightRail.position.z = TRAIN_GROUP.position.z + 500;
            grid.position.z = TRAIN_GROUP.position.z;

            renderer.render(scene, camera);
        }
        animate();

        // Inputs
        document.getElementById('btn-next').addEventListener('click', nextBeat);
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') nextBeat(); });

        // Start
        nextBeat();

    </script>
</body>

</html>