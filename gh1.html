<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>THE HELIX // Infinite Genome</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>

    <style>
        :root {
            --bg: #000203;
            --term: #050a10;
            --line: #1f293a;
            --accent: #00f0ff;
            /* Strand A */
            --accent-alt: #ff0055;
            /* Strand B */
            --text: #a0c0d0;
            --font: 'Courier New', monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            color: var(--text);
            font-family: var(--font);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Scanlines */
        .scanlines::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: radial-gradient(circle, transparent 60%, #000 140%),
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 50;
            background-size: 100% 100%, 100% 2px, 3px 100%;
            pointer-events: none;
        }

        #app {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: 1fr 350px;
            transition: grid-template-columns 0.3s ease;
        }

        #viewport {
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }

        /* --- GENOME MINIMAP (Left Side) --- */
        #genome-minimap {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 60px;
            background: rgba(5, 10, 16, 0.95);
            border-right: 1px solid var(--line);
            z-index: 40;
            display: flex;
            flex-direction: column;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        #genome-minimap.expanded {
            width: 220px;
        }

        .map-header {
            padding: 15px 0;
            text-align: center;
            border-bottom: 1px solid var(--line);
            cursor: pointer;
            background: #000;
        }

        .map-header:hover {
            color: #fff;
        }

        .map-icon {
            font-size: 18px;
            margin-bottom: 4px;
            display: block;
        }

        .map-label {
            font-size: 9px;
            letter-spacing: 2px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            margin: 20px auto;
            opacity: 0.6;
        }

        #genome-minimap.expanded .map-label {
            writing-mode: horizontal-tb;
            transform: none;
            margin: 0;
        }

        .map-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column-reverse;
            /* Newest at bottom */
            gap: 4px;
            padding: 10px 4px;
            scrollbar-width: none;
        }

        /* Map Node */
        .g-node {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.03);
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
            position: relative;
        }

        .g-node:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #444;
        }

        .g-marker {
            width: 4px;
            height: 32px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .g-marker.A {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .g-marker.B {
            background: var(--accent-alt);
            box-shadow: 0 0 8px var(--accent-alt);
        }

        .g-imgs {
            position: relative;
            width: 32px;
            height: 32px;
            flex-shrink: 0;
        }

        .g-img {
            width: 100%;
            height: 100%;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid #333;
        }

        .g-img.dead {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 16px;
            height: 16px;
            filter: grayscale(100%) brightness(0.5);
            border: 1px solid #555;
            z-index: 2;
        }

        .g-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            opacity: 0;
            transition: opacity 0.2s;
            font-weight: 900;
        }

        .g-node:hover .g-overlay {
            opacity: 1;
        }

        /* Expanded Details */
        .g-details {
            opacity: 0;
            width: 0;
            overflow: hidden;
            white-space: nowrap;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: opacity 0.2s 0.1s;
        }

        #genome-minimap.expanded .g-details {
            opacity: 1;
            width: auto;
            padding-right: 10px;
        }

        .gd-title {
            font-size: 10px;
            color: #fff;
            font-weight: 700;
        }

        .gd-sub {
            font-size: 9px;
            color: #666;
        }

        .gd-kill {
            font-size: 9px;
            color: #ff3355;
            margin-top: 2px;
        }

        /* --- HUD OVERLAY --- */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 60px;
            right: 0;
            padding: 20px;
            pointer-events: none;
            z-index: 10;
            transition: left 0.3s;
        }

        #genome-minimap.expanded~#viewport #hud-layer {
            left: 220px;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
        }

        .strand-indicator {
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 20px currentColor;
        }

        /* --- TARGETING CARDS --- */
        #targeting-display {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            display: flex;
            justify-content: space-between;
            gap: 20px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #targeting-display.active {
            opacity: 1;
        }

        .target-card {
            flex: 1;
            background: rgba(0, 5, 10, 0.9);
            border: 1px solid #333;
            padding: 12px;
            border-radius: 4px;
            backdrop-filter: blur(8px);
            transform: scale(0.95);
            transition: all 0.3s;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .target-card.A {
            border-left: 3px solid var(--accent);
        }

        .target-card.B {
            border-right: 3px solid var(--accent-alt);
            flex-direction: row-reverse;
            text-align: right;
        }

        .target-card.locked {
            transform: scale(1.05);
            background: rgba(0, 20, 40, 0.95);
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            z-index: 5;
        }

        .t-img {
            width: 48px;
            height: 48px;
            border-radius: 4px;
            background: #000;
            border: 1px solid #444;
            flex-shrink: 0;
        }

        .t-name {
            font-size: 14px;
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
        }

        .t-bio {
            font-size: 10px;
            color: #aaa;
            margin-top: 2px;
        }

        .t-plea {
            font-size: 11px;
            color: #fff;
            font-style: italic;
            margin-top: 4px;
        }

        /* --- CONTROLS --- */
        #controls-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .ctrl-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 6px;
        }

        .cam-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #888;
            padding: 8px 12px;
            font-family: inherit;
            font-size: 9px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            min-width: 60px;
        }

        .cam-btn:hover {
            color: #fff;
            border-color: #fff;
        }

        .cam-btn.active {
            color: var(--accent);
            border-color: var(--accent);
            background: rgba(0, 240, 255, 0.1);
        }

        .cam-btn.alert {
            color: var(--accent-alt);
            border-color: var(--accent-alt);
        }

        .cam-btn.pov-a {
            color: var(--accent);
        }

        .cam-btn.pov-a.active {
            background: rgba(0, 240, 255, 0.2);
        }

        .cam-btn.pov-b {
            color: var(--accent-alt);
        }

        .cam-btn.pov-b.active {
            background: rgba(255, 0, 85, 0.2);
        }

        /* LEVER */
        #manual-override {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            text-align: center;
            cursor: pointer;
            pointer-events: auto;
        }

        .lever-base {
            width: 70px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
            border-radius: 35px;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }

        .lever-stick {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            position: absolute;
            left: 8px;
            transition: top 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: #fff;
            box-shadow: 0 0 20px #fff;
        }

        .strand-A .lever-stick {
            top: 10px;
            background: var(--accent);
        }

        .strand-B .lever-stick {
            top: 56px;
            background: var(--accent-alt);
        }

        /* Terminal */
        #terminal {
            background: var(--term);
            border-left: 1px solid var(--line);
            display: flex;
            flex-direction: column;
            z-index: 20;
        }

        #chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .msg {
            display: flex;
            gap: 8px;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.02);
        }

        .msg img {
            width: 24px;
            height: 24px;
            border-radius: 2px;
        }

        @media (max-width: 900px) {
            #app {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 0px;
            }

            /* Hide terminal on mobile default */
            #terminal {
                display: none;
            }

            /* Hide chat on mobile to focus on vis */
            #genome-minimap {
                width: 50px;
            }

            #genome-minimap.expanded {
                width: 200px;
            }

            #targeting-display {
                flex-direction: column;
                top: 15%;
                width: 90%;
                gap: 10px;
            }

            .target-card {
                padding: 10px;
            }

            .t-img {
                width: 40px;
                height: 40px;
            }

            .t-name {
                font-size: 12px;
            }

            #controls-overlay {
                top: auto;
                bottom: 180px;
                right: 20px;
            }
        }
    </style>
</head>

<body>

    <div id="app" class="scanlines">

        <!-- GENOME MINIMAP (Collapsible Sidebar) -->
        <div id="genome-minimap">
            <div class="map-header" onclick="toggleMap()">
                <span class="map-icon">ðŸ§¬</span>
                <div class="map-label">GENOME</div>
            </div>
            <div class="map-content" id="genome-list">
                <!-- Nodes added here -->
            </div>
        </div>

        <div id="viewport">
            <!-- HUD Layer -->
            <div id="hud-layer">
                <div class="hud-top">
                    <div>
                        <div class="hud-stat">SEQUENCER v14</div>
                        <div class="hud-stat" id="dist" style="color:#666">0 BP</div>
                    </div>
                    <div class="strand-indicator" id="strandDisplay" style="color:var(--accent)">ALPHA</div>
                </div>
            </div>

            <!-- Fighter Pilot Targeting System -->
            <div id="targeting-display">
                <!-- Left Card (A) -->
                <div class="target-card A" id="card-A">
                    <img src="" id="img-A" class="t-img">
                    <div class="t-data">
                        <div class="t-header">STRAND ALPHA</div>
                        <div class="t-name" id="name-A">--</div>
                        <div class="t-bio" id="bio-A">--</div>
                        <div class="t-plea" id="plea-A">"--"</div>
                    </div>
                </div>

                <!-- Right Card (B) -->
                <div class="target-card B" id="card-B">
                    <div class="t-data">
                        <div class="t-header">STRAND BETA</div>
                        <div class="t-name" id="name-B">--</div>
                        <div class="t-bio" id="bio-B">--</div>
                        <div class="t-plea" id="plea-B">"--"</div>
                    </div>
                    <img src="" id="img-B" class="t-img">
                </div>
            </div>

            <!-- Controls -->
            <div id="controls-overlay">
                <div class="ctrl-grid">
                    <button class="cam-btn alert" id="btn-pause" onclick="togglePause()">PAUSE</button>
                    <button class="cam-btn" id="btn-tts" onclick="toggleTTS()">TTS: ON</button>

                    <button class="cam-btn active" onclick="setCam('TUNNEL')">TUNNEL</button>
                    <button class="cam-btn" onclick="setCam('FORK')">FORK</button>

                    <button class="cam-btn pov-a" onclick="setCam('POV_A')">POV A</button>
                    <button class="cam-btn pov-b" onclick="setCam('POV_B')">POV B</button>

                    <button class="cam-btn" onclick="setCam('CHASE')">CHASE</button>
                    <button class="cam-btn" onclick="setCam('DRONE')">DRONE</button>
                </div>

                <div
                    style="background:rgba(0,0,0,0.8); padding:0 8px; border:1px solid #333; display:flex; align-items:center; width: 100%;">
                    <span style="font-size:9px; color:#666; margin-right:5px;">SPD</span>
                    <input type="range" min="0" max="200" value="10" style="flex:1; accent-color: white;"
                        oninput="CFG.speed=this.value/100">
                </div>
            </div>

            <!-- Lever -->
            <div id="manual-override" onclick="toggleStrand()">
                <div class="lever-base strand-A" id="leverVisual">
                    <div class="lever-stick"></div>
                </div>
                <div
                    style="font-size:10px; font-weight:900; background:#000; color:#fff; padding:4px 8px; margin-top:10px; letter-spacing:1px;">
                    SWITCH</div>
            </div>
        </div>

        <!-- Terminal -->
        <div id="terminal">
            <div class="term-header" style="padding:10px; font-size:10px;">COMM LOG</div>
            <div id="chat-container">
                <div class="msg system">
                    <div style="flex:1">Neural Link Established.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CFG = {
            helixRadius: 14,
            helixTwist: 0.15,
            speed: 0.1,
            fov: 75,
            fogDensity: 0.006,
            decisionInterval: 180,
            colors: { A: 0x00f0ff, B: 0xff0055, bridge: 0xffffff, bridgeHover: 0xffff00 },
            tts: true
        };

        // --- STATE ---
        const STATE = {
            playing: true,
            paused: false,
            distance: 0,
            currentStrand: 'A',
            targetStrand: 'A',
            strandLerp: 0,
            entities: [],
            chunks: [],
            nextDecisionZ: 50,
            cameraMode: 'TUNNEL',
            genome: [],
            approachingPair: null,
            lastSpokenZ: -1
        };

        let noise = null;
        let synth = null;

        // --- DATA GENERATOR ---
        const ROLES = ["Physicist", "Farmer", "Pilot", "Archivist", "Artist", "Splicer", "Miner", "Diplomat", "Child", "Elder"];
        const ETHNICITIES = ["Martian", "Terran", "Belter", "Jovian", "Lunar"];
        const GENDERS = ["M", "F", "NB"];
        const BIOS = [
            "Carrying the cure for the Rot.", "Three children waiting on Phobos.",
            "Stole rations to feed a colony.", "Designed this very train.",
            "Writing a poem to end the war.", "Carrying a dormant virus.",
            "Owes you a life debt.", "Last survivor of Sector 7."
        ];
        const PLEAS = [
            "I have a family!", "Don't do this!", "I can save them!", "Witness me!",
            "Look at me!", "Not like this!", "I'm innocent!", "You know me!",
            "Mercy!", "I am the future!"
        ];

        function generatePersona() {
            const seed = Math.random().toString(36).substring(7);
            const role = ROLES[Math.floor(Math.random() * ROLES.length)];
            const plea = PLEAS[Math.floor(Math.random() * PLEAS.length)];
            const bio = BIOS[Math.floor(Math.random() * BIOS.length)];
            const gender = GENDERS[Math.floor(Math.random() * GENDERS.length)];
            const age = Math.floor(Math.random() * 70) + 10;

            return {
                name: `Subject ${seed.toUpperCase()}`,
                role, plea, bio, gender, age, ethnicity: ETHNICITIES[Math.floor(Math.random() * ETHNICITIES.length)],
                img: `https://api.dicebear.com/9.x/avataaars/svg?seed=${seed}&backgroundColor=b6e3f4,c0aede,d1d4f9`
            };
        }

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000203);
        scene.fog = new THREE.FogExp2(0x000203, CFG.fogDensity);

        const camera = new THREE.PerspectiveCamera(CFG.fov, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        const viewport = document.getElementById('viewport');
        viewport.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Lighting
        scene.add(new THREE.HemisphereLight(0xffffff, 0x000000, 0.4));
        const gridHelper = new THREE.GridHelper(3000, 150, 0x111111, 0x050505);
        gridHelper.position.y = -25; scene.add(gridHelper);

        // Stars
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 4000;
        const posArray = new Float32Array(starsCount * 3);
        for (let i = 0; i < starsCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 800;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: 0.4, color: 0x555555, transparent: true, opacity: 0.6 }));
        scene.add(stars);

        // --- TRAIN ---
        const trainGroup = new THREE.Group();
        scene.add(trainGroup);

        // Train Geometry
        const tMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.8, emissive: 0x111111 });
        const tGlowMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff });

        const tBody = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.2, 8.0), tMat);
        tBody.position.y = 0.6; trainGroup.add(tBody);

        const tEngine = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.6, 6.0, 16), tMat);
        tEngine.rotation.x = Math.PI / 2; tEngine.position.set(0, 2.0, 0.5); trainGroup.add(tEngine);

        const tCore = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 8.5, 8), tGlowMat);
        tCore.rotation.x = Math.PI / 2; tCore.position.set(0, 2.0, 0); trainGroup.add(tCore);

        // Light
        const spot = new THREE.SpotLight(0xffffff, 30, 500, 0.6, 0.8, 1);
        spot.position.set(0, 5, 3); spot.target.position.set(0, 2, 80);
        trainGroup.add(spot); trainGroup.add(spot.target);

        const beam = new THREE.Mesh(
            new THREE.ConeGeometry(8, 120, 32, 1, true),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.08, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false })
        );
        beam.rotation.x = -Math.PI / 2; beam.position.set(0, 5, 60); trainGroup.add(beam);

        // --- HELIX & GENERATION ---
        function getHelixPos(z, strand) {
            const angle = z * CFG.helixTwist;
            const offset = strand === 'A' ? 0 : Math.PI;
            return { x: Math.cos(angle + offset) * CFG.helixRadius, y: Math.sin(angle + offset) * CFG.helixRadius, z: z };
        }
        function getTangent(z, strand) {
            const p1 = getHelixPos(z, strand);
            const p2 = getHelixPos(z + 0.1, strand);
            return new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z).normalize();
        }

        const chunkGeom = new THREE.BoxGeometry(1.0, 0.2, 3.0);
        const bridgeGeom = new THREE.BoxGeometry(0.5, 0.5, CFG.helixRadius * 2);

        function createChunk(z) {
            const group = new THREE.Group();
            ['A', 'B'].forEach(s => {
                const pos = getHelixPos(z, s);
                const m = new THREE.Mesh(chunkGeom, new THREE.MeshBasicMaterial({ color: CFG.colors[s] }));
                m.position.set(pos.x, pos.y, pos.z);
                m.lookAt(m.position.clone().add(getTangent(z, s)));
                m.userData = { strand: s, type: 'rail' };
                group.add(m);
            });
            if (Math.floor(z) % 15 === 0) {
                const b = new THREE.Mesh(bridgeGeom, new THREE.MeshBasicMaterial({ color: CFG.colors.bridge, transparent: true, opacity: 0.5 }));
                b.position.set(0, 0, z);
                b.rotation.z = (z * CFG.helixTwist) + Math.PI / 2;
                b.userData = { type: 'bridge' };
                group.add(b);
            }
            return group;
        }

        // --- HUD & INTERACTION ---
        function updateHUD(distToNext, charA, charB, entA, entB) {
            const display = document.getElementById('targeting-display');

            if (distToNext < 250 && distToNext > 0) {
                display.classList.add('active');

                if (STATE.approachingPair?.z !== STATE.nextDecisionZ) {
                    STATE.approachingPair = { z: STATE.nextDecisionZ };

                    const updateCard = (id, char) => {
                        document.getElementById(`name-${id}`).innerText = char.name;
                        document.getElementById(`bio-${id}`).innerText = `${char.age}yo ${char.role}. ${char.bio}`;
                        document.getElementById(`plea-${id}`).innerText = `"${char.plea}"`;
                        document.getElementById(`img-${id}`).src = char.img;
                    };
                    updateCard('A', charA);
                    updateCard('B', charB);

                    if (CFG.tts && STATE.lastSpokenZ !== STATE.nextDecisionZ && distToNext < 150) {
                        speak(charA.plea, 'A');
                        setTimeout(() => speak(charB.plea, 'B'), 2000);
                        STATE.lastSpokenZ = STATE.nextDecisionZ;
                    }
                }

                const cardA = document.getElementById('card-A');
                const cardB = document.getElementById('card-B');
                if (STATE.targetStrand === 'A') { cardA.classList.add('locked'); cardB.classList.remove('locked'); }
                else { cardB.classList.add('locked'); cardA.classList.remove('locked'); }

            } else {
                display.classList.remove('active');
            }
        }

        function speak(text, strand) {
            if (!window.speechSynthesis) return;
            const utt = new SpeechSynthesisUtterance(text);
            const voices = window.speechSynthesis.getVoices();
            utt.voice = strand === 'A' ? voices[0] : voices[Math.min(1, voices.length - 1)];
            utt.rate = 1.1;
            window.speechSynthesis.speak(utt);
        }

        function toggleMap() {
            document.getElementById('genome-minimap').classList.toggle('expanded');
        }

        function toggleTTS() {
            CFG.tts = !CFG.tts;
            document.getElementById('btn-tts').innerText = `TTS: ${CFG.tts ? 'ON' : 'OFF'}`;
            document.getElementById('btn-tts').classList.toggle('active', CFG.tts);
        }

        function togglePause() {
            STATE.paused = !STATE.paused;
            document.getElementById('btn-pause').innerText = STATE.paused ? "RESUME" : "PAUSE";
            document.getElementById('btn-pause').classList.toggle('active', STATE.paused);
        }

        function updateGenomeMinimap(genomeItem) {
            const list = document.getElementById('genome-list');
            const div = document.createElement('div');
            div.className = 'g-node';
            div.onclick = () => rewindTo(genomeItem.z);

            // Create Node Content
            div.innerHTML = `
    <div class="g-marker ${genomeItem.choice}"></div>
    <div class="g-imgs">
      <img class="g-img" src="${genomeItem.data.img}">
      <div class="g-overlay">REWIND</div>
    </div>
    <div class="g-imgs" style="opacity:0.5; margin-left:-10px; z-index:-1;">
      <img class="g-img" style="filter:grayscale(100%)" src="${genomeItem.sacrificed.img}">
      <div class="g-img dead"></div>
    </div>
    <div class="g-details">
      <div class="gd-title">SPARED: ${genomeItem.data.name.split(' ')[1]}</div>
      <div class="gd-sub">${genomeItem.data.role}</div>
      <div class="gd-kill">LOST: ${genomeItem.sacrificed.name.split(' ')[1]}</div>
    </div>
  `;

            // Insert at top (newest first)
            list.insertBefore(div, list.firstChild);
        }

        function rewindTo(z) {
            STATE.paused = false;
            document.getElementById('btn-pause').innerText = "PAUSE";
            document.getElementById('btn-pause').classList.remove('active');

            if (z >= STATE.distance) return;
            STATE.distance = z;
            STATE.nextDecisionZ = Math.ceil(z / CFG.decisionInterval) * CFG.decisionInterval;
            STATE.lastSpokenZ = -1;

            // Clean up
            for (let i = STATE.entities.length - 1; i >= 0; i--) {
                if (STATE.entities[i].z > z) {
                    scene.remove(STATE.entities[i].mesh);
                    if (STATE.entities[i].sprite) scene.remove(STATE.entities[i].sprite);
                    STATE.entities.splice(i, 1);
                }
            }

            // Rebuild Minimap from history
            STATE.genome = STATE.genome.filter(g => g.z <= z);
            document.getElementById('genome-list').innerHTML = '';
            STATE.genome.forEach(g => updateGenomeMinimap(g));

            addLog("system", `REWIND COMPLETE: BP ${z}`);
        }

        function addLog(type, text, img) {
            const c = document.getElementById('chat-container');
            const d = document.createElement('div');
            d.className = `msg ${type}`;
            d.innerHTML = `${img ? `<img src="${img}">` : ''}<div class="content">${text}</div>`;
            c.appendChild(d);
            c.scrollTop = c.scrollHeight;
        }

        // --- SPAWNING ---
        function spawnDecisionNode(z) {
            const charA = generatePersona();
            const charB = generatePersona();

            const entA = createEntity(z, 'A', charA);
            const entB = createEntity(z, 'B', charB);

            entA.partner = charB; entA.mesh.userData.isDecision = true;
            entB.partner = charA; entB.mesh.userData.isDecision = true;

            STATE.entities.push(entA, entB);
        }

        function createEntity(z, strand, char) {
            const pos = getHelixPos(z, strand);
            const color = CFG.colors[strand];

            // Mesh
            const geom = new THREE.ConeGeometry(1.5, 5, 4);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.lookAt(0, 0, pos.z); mesh.rotateX(Math.PI / 2);
            scene.add(mesh);

            // Sprite
            let sprite = null;
            textureLoader.load(char.img, (tex) => {
                sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
                const outward = new THREE.Vector3().subVectors(mesh.position, new THREE.Vector3(0, 0, pos.z)).normalize();
                sprite.position.copy(mesh.position.clone().add(outward.multiplyScalar(6)));
                sprite.scale.set(8, 8, 1);
                scene.add(sprite);
            });

            return { mesh, sprite, z, strand, data: char };
        }

        // --- MAIN LOOP ---
        function updatePhysics() {
            if (!STATE.playing || STATE.paused) return;
            STATE.distance += CFG.speed;

            // Train Movement
            const targetLerp = STATE.targetStrand === 'B' ? 1 : 0;
            STATE.strandLerp += (targetLerp - STATE.strandLerp) * 0.1;
            const posA = getHelixPos(STATE.distance, 'A');
            const posB = getHelixPos(STATE.distance, 'B');
            const x = posA.x + (posB.x - posA.x) * STATE.strandLerp;
            const y = posA.y + (posB.y - posA.y) * STATE.strandLerp;
            const z = STATE.distance;
            trainGroup.position.set(x, y, z);

            const tanA = getTangent(z, 'A');
            const tanB = getTangent(z, 'B');
            const lookX = tanA.x + (tanB.x - tanA.x) * STATE.strandLerp;
            const lookY = tanA.y + (tanB.y - tanA.y) * STATE.strandLerp;
            const lookZ = tanA.z + (tanB.z - tanA.z) * STATE.strandLerp;
            trainGroup.lookAt(x + lookX, y + lookY, z + lookZ);

            // Camera Logic (Updated)
            if (STATE.cameraMode === 'TUNNEL') {
                camera.position.lerp(new THREE.Vector3(0, 0, z - 30), 0.1);
                camera.lookAt(0, 0, z + 60);
            }
            else if (STATE.cameraMode === 'DRONE') {
                camera.position.lerp(new THREE.Vector3(0, 60, z - 10), 0.05);
                camera.lookAt(0, 0, z + 40);
            }
            else if (STATE.cameraMode === 'FORK') {
                // Look ahead at the next decision point from a high angle
                const targetZ = STATE.nextDecisionZ;
                camera.position.lerp(new THREE.Vector3(0, 20, targetZ - 40), 0.08);
                camera.lookAt(0, 0, targetZ);
            }
            else if (STATE.cameraMode === 'POV_A' || STATE.cameraMode === 'POV_B') {
                const targetStrand = STATE.cameraMode === 'POV_A' ? 'A' : 'B';
                const targetEnt = STATE.entities.find(e => e.z > STATE.distance + 10 && e.strand === targetStrand);

                if (targetEnt) {
                    // Position camera on the entity's "head" looking at the train
                    const eyePos = targetEnt.mesh.position.clone().add(new THREE.Vector3(0, 4, 0));
                    camera.position.lerp(eyePos, 0.1);
                    camera.lookAt(trainGroup.position);
                } else {
                    // Fallback to CHASE if no entity
                    const offset = new THREE.Vector3(0, 6, -15).applyQuaternion(trainGroup.quaternion);
                    camera.position.lerp(new THREE.Vector3(x, y, z).add(offset), 0.1);
                    camera.lookAt(x, y, z + 20);
                }
            }
            else {
                // CHASE
                const offset = new THREE.Vector3(0, 6, -15).applyQuaternion(trainGroup.quaternion);
                camera.position.lerp(new THREE.Vector3(x, y, z).add(offset), 0.1);
                camera.lookAt(x, y, z + 20);
            }

            // Chunks
            const lastZ = STATE.chunks.length > 0 ? STATE.chunks[STATE.chunks.length - 1].userData.z : STATE.distance;
            if (lastZ < STATE.distance + 300) {
                for (let i = 0; i < 10; i++) {
                    const nz = lastZ + i + 1;
                    const c = createChunk(nz); c.userData = { z: nz };
                    scene.add(c); STATE.chunks.push(c);
                }
            }
            if (STATE.chunks.length && STATE.chunks[0].userData.z < STATE.distance - 50) {
                scene.remove(STATE.chunks.shift());
            }

            // Logic
            if (STATE.distance > STATE.nextDecisionZ) {
                spawnDecisionNode(STATE.nextDecisionZ + 100);
                STATE.nextDecisionZ += CFG.decisionInterval;
            }

            // Find next pair for HUD
            const nextPair = STATE.entities.filter(e => e.z > z && e.z < z + 250);
            if (nextPair.length >= 2) {
                updateHUD(nextPair[0].z - z, nextPair[0].data, nextPair[1].data, nextPair[0], nextPair[1]);
            } else {
                updateHUD(-1);
            }

            // Collision
            STATE.entities.forEach((ent, idx) => {
                if (ent.z < z - 2 && ent.z > z - 10) {
                    const isHit = (ent.strand === 'A' && STATE.strandLerp < 0.2) || (ent.strand === 'B' && STATE.strandLerp > 0.8);
                    if (isHit && ent.mesh.visible) {
                        ent.mesh.visible = false;
                        if (ent.sprite) ent.sprite.visible = false;

                        const gItem = { z: Math.floor(ent.z), choice: ent.strand === 'A' ? 'A' : 'B', data: ent.data, sacrificed: ent.data };
                        STATE.genome.push(gItem);
                        updateGenomeMinimap(gItem);

                        addLog(ent.strand, `<b>TERMINATED:</b> ${ent.data.name}`, ent.data.img);
                        camera.position.add(new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), 0));
                    }
                }
                if (ent.z < z - 100) {
                    scene.remove(ent.mesh); if (ent.sprite) scene.remove(ent.sprite);
                    STATE.entities.splice(idx, 1);
                }
            });

            stars.position.z = STATE.distance;
            document.getElementById('dist').innerText = `${STATE.distance.toFixed(0)} BP`;
        }

        // --- UTILS ---
        function toggleStrand() {
            if (STATE.paused) return;
            STATE.targetStrand = STATE.targetStrand === 'A' ? 'B' : 'A';
            const knob = document.getElementById('leverVisual');
            const label = document.getElementById('strandDisplay');
            if (STATE.targetStrand === 'A') {
                knob.classList.remove('strand-B'); knob.classList.add('strand-A');
                label.innerText = "STRAND ALPHA"; label.style.color = "var(--accent)";
            } else {
                knob.classList.remove('strand-A'); knob.classList.add('strand-B');
                label.innerText = "STRAND BETA"; label.style.color = "var(--accent-alt)";
            }
            if (noise) {
                const m = new Tone.MembraneSynth().toDestination();
                m.triggerAttackRelease("C2", "8n");
            }
        }

        function setCam(m) { STATE.cameraMode = m; document.querySelectorAll('.cam-btn').forEach(b => b.classList.remove('active')); event.target.classList.add('active'); }

        async function initAudio() {
            await Tone.start();
            noise = new Tone.Noise("brown").start(); noise.volume.value = -20;
            const f = new Tone.AutoFilter({ frequency: "8n", baseFrequency: 200, octaves: 2.6 }).toDestination().start();
            noise.connect(f);
        }

        viewport.addEventListener('mousedown', (e) => {
            if (STATE.paused) return;
            mouse.x = (e.clientX / viewport.clientWidth) * 2 - 1;
            mouse.y = -(e.clientY / viewport.clientHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);
            if (hits.length) {
                let t = hits[0].object;
                while (t && !t.userData.strand && t.userData.type !== 'bridge') t = t.parent;
                if (t && (t.userData.strand || t.userData.type === 'bridge')) toggleStrand();
            }
        });

        function animate() { requestAnimationFrame(animate); updatePhysics(); renderer.render(scene, camera); }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        initAudio();
        animate();

    </script>
</body>

</html>