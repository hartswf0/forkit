<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: When the System Scales (Train Sequence)</title>
    <style>
        :root {
            --bg-color: #000203;
            --font-mono: 'Courier New', Courier, monospace;
            --font-sans: 'Inter', system-ui, sans-serif;
            --primary: #ff9900;
            /* Act 2 Orange/Queue color */
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: #ccc;
            font-family: var(--font-sans);
            overflow: hidden;
            height: 100vh;
        }

        #viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #hud-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, transparent 20%, transparent 80%, rgba(0, 0, 0, 0.8) 100%);
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-family: var(--font-mono);
            font-size: 14px;
            color: var(--primary);
            text-shadow: 0 0 5px rgba(255, 153, 0, 0.5);
        }

        .hud-bottom {
            padding: 40px;
            text-align: center;
        }

        .beat-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .beat-desc {
            font-size: 16px;
            color: #aaa;
            max-width: 600px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid #333;
        }

        #controls {
            pointer-events: auto;
        }

        .btn {
            background: rgba(255, 153, 0, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 20px;
            font-family: var(--font-mono);
            cursor: pointer;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 153, 0, 0.3);
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>

<body>

    <div id="viewport"></div>

    <div id="hud-layer">
        <div class="hud-top">
            <div id="sys-name">GREMLIN_ARCHIVES // ACT_2</div>
            <div>STATUS: <span id="status-ind">SCALING UP</span></div>
        </div>

        <div class="hud-bottom">
            <div id="beat-display">
                <div class="beat-title" id="beat-title">--</div>
                <div class="beat-desc" id="beat-desc">--</div>
            </div>
            <div id="controls" style="margin-top: 20px;">
                <button class="btn" id="btn-next">NEXT BEAT [SPACE]</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. DATA (ACT 2: When the System Scales) ---
        const ACT_DATA = [
            { id: "B1", title: "Scene: Promise World", desc: "Inviting. Frictionless. Everything is shared.", type: "PROMISE" },
            { id: "P1", title: "Pressure: Scale Collision", desc: "Millions of users. Trust breaks. Brand risk.", type: "PRESSURE" },
            { id: "B2", title: "Scene: The Queue", desc: "Endless scroll of creations. Waiting for approval.", type: "QUEUE" },
            { id: "B3", title: "Scene: The Moderators", desc: "Human filters. Decisions in seconds. Context lost.", type: "MODS" },
            { id: "P2", title: "Pressure: Cost Curve", desc: "Labor is linear. Creation is exponential. The math fails.", type: "COST" },
            { id: "B4", title: "Scene: System Strain", desc: "Dashboards red. Silent executive panic.", type: "STRAIN" },
            { id: "B5", title: "Failure: Shutdown", desc: "The world turns off. Instant erasure.", type: "SHUTDOWN" },
            { id: "B6", title: "Road Not Taken: Voxel", desc: "1990s Voxel terrain. Solid. Data as volume.", type: "VOXEL" },
            { id: "K1", title: "Contradiction: Surface vs Vol", desc: "Triangles (Surface) vs Voxels (Matter).", type: "VERSUS" },
            { id: "B7", title: "Scene: The Infinite Island", desc: "Euclideon demo. Unlimited detail. The impossible promise.", type: "DEMO" },
            { id: "P3", title: "Pressure: Hardware Lock-in", desc: "GPUs optimize for triangles. Voxels die.", type: "LOCKIN" },
            { id: "B8", title: "Scene: Aborted Lineage", desc: "The voxel branch fades. The polygon branch glows.", type: "TIMELINE" },
            { id: "A2", title: "Act Button", desc: "Promise: Better Worlds. Threat: Invisible Labor.", type: "BUTTON" }
        ];

        let currentBeat = -1;

        // --- 2. THREE.JS ENGINE (TRAIN CHASSIS) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('viewport').appendChild(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.6);
        scene.add(hemiLight);
        const spotLight = new THREE.SpotLight(0xffaa00, 1);
        spotLight.position.set(0, 20, 0);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // GROUND
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x111111, depthWrite: false }));
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);
        const grid = new THREE.GridHelper(2000, 200, 0x333333, 0x111111);
        scene.add(grid);

        // TRACKS (Infinite Straight)
        const TRAIN_GROUP = new THREE.Group();
        scene.add(TRAIN_GROUP);

        // Train Body
        const cab = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 6), new THREE.MeshStandardMaterial({ color: 0x302520, roughness: 0.6 })); // slightly orange tint
        cab.position.y = 2.5;
        TRAIN_GROUP.add(cab);

        // Cockpit Camera
        camera.position.set(0, 3.5, 2.5);
        camera.lookAt(0, 2.5, 20);
        TRAIN_GROUP.add(camera);

        // Dashboard
        const dash = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 1), new THREE.MeshBasicMaterial({ color: 0x110500 }));
        dash.position.set(0, 2.5, 3);
        TRAIN_GROUP.add(dash);

        // Rails
        const railGeo = new THREE.BoxGeometry(0.2, 0.2, 1000);
        const railMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 });
        const leftRail = new THREE.Mesh(railGeo, railMat); leftRail.position.set(-1.5, 0.1, 500);
        const rightRail = new THREE.Mesh(railGeo, railMat); rightRail.position.set(1.5, 0.1, 500);
        scene.add(leftRail); scene.add(rightRail);

        // --- 3. SPOTLIGHT & EXHIBITS ---
        const focusSpot = new THREE.SpotLight(0xffffff, 2, 200, 0.3, 0.5, 1);
        focusSpot.position.set(0, 10, 0);
        focusSpot.castShadow = true;
        focusSpot.target.position.set(0, 0, 50);
        TRAIN_GROUP.add(focusSpot);
        scene.add(focusSpot.target);

        const BEAT_SPACING = 100;
        const EXHIBITS = [];

        function createExhibits() {
            ACT_DATA.forEach((beat, i) => {
                const zPos = (i + 1) * BEAT_SPACING;
                const group = new THREE.Group();
                group.position.set(0, 0, zPos);

                const platform = new THREE.Mesh(new THREE.CylinderGeometry(12, 12, 0.5, 32), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                platform.position.y = 0.25;
                group.add(platform);

                // BESPOKE CONTENT
                let content = new THREE.Group();
                const matBlue = new THREE.MeshStandardMaterial({ color: 0x0088ff });
                const matOrange = new THREE.MeshStandardMaterial({ color: 0xff9900 });

                if (beat.type === "PROMISE") {
                    // Floating shiny spheres
                    for (let k = 0; k < 5; k++) {
                        const s = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshStandardMaterial({ color: 0x00ffff, metalness: 0.9, roughness: 0.1 }));
                        s.position.set((Math.random() - 0.5) * 8, 2 + Math.random() * 4, (Math.random() - 0.5) * 8);
                        content.add(s);
                    }
                }
                else if (beat.type === "PRESSURE" || beat.type === "COST") {
                    // Graph going up
                    const lineGeo = new THREE.BufferGeometry();
                    const pts = [];
                    for (let x = 0; x < 10; x++) pts.push(new THREE.Vector3(x - 5, x * 0.8, 0));
                    lineGeo.setFromPoints(pts);
                    const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 }));
                    content.add(line);
                    content.position.y = 2;
                }
                else if (beat.type === "QUEUE") {
                    for (let k = 0; k < 15; k++) {
                        const b = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), matOrange);
                        b.position.set(0, 0.5, -10 + k * 1.5);
                        content.add(b);
                    }
                }
                else if (beat.type === "MODS") {
                    // Two gates
                    const yes = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 0.5), new THREE.MeshStandardMaterial({ color: 0x00ff00 })); yes.position.x = -3;
                    const no = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 0.5), new THREE.MeshStandardMaterial({ color: 0xff0000 })); no.position.x = 3;
                    content.add(yes, no);
                    content.position.y = 2;
                }
                else if (beat.type === "STRAIN") {
                    // Flashing Red Box
                    const b = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 4), new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 }));
                    content.add(b);
                    content.position.y = 2;
                }
                else if (beat.type === "SHUTDOWN") {
                    // Power Switch
                    const base = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 4), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                    const handle = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 1), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                    handle.rotation.z = -Math.PI / 4; // Off position
                    handle.position.y = 2;
                    content.add(base, handle);
                }
                else if (beat.type === "VOXEL") {
                    // Voxel Chunk
                    for (let x = 0; x < 4; x++) for (let y = 0; y < 4; y++) for (let z = 0; z < 4; z++) {
                        if (Math.random() > 0.3) {
                            const v = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                            v.position.set(x - 1.5, y, z - 1.5);
                            content.add(v);
                        }
                    }
                }
                else if (beat.type === "VERSUS") {
                    const tri = new THREE.Mesh(new THREE.ConeGeometry(2, 3, 4), matBlue); tri.position.x = -3;
                    const vox = new THREE.Group(); vox.position.x = 3;
                    for (let k = 0; k < 8; k++) {
                        const v = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), matOrange);
                        v.position.set(0, k * 0.6, 0);
                        vox.add(v);
                    }
                    content.add(tri, vox);
                    content.position.y = 2;
                }
                else if (beat.type === "DEMO") {
                    // Point Cloud
                    const pGeo = new THREE.BufferGeometry();
                    const pts = [];
                    for (let k = 0; k < 1000; k++) pts.push((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
                    pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
                    content.add(new THREE.Points(pGeo, new THREE.PointsMaterial({ size: 0.05, color: 0x00ff00 })));
                    content.position.y = 3;
                }
                else if (beat.type === "LOCKIN") {
                    // GPU Fan
                    const frame = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                    const fan1 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.2), new THREE.MeshBasicMaterial({ color: 0x333333 })); fan1.position.x = -1.5; fan1.position.y = 0.5;
                    const fan2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.2), new THREE.MeshBasicMaterial({ color: 0x333333 })); fan2.position.x = 1.5; fan2.position.y = 0.5;
                    content.add(frame, fan1, fan2);
                    content.position.y = 2;
                    fan1.userData = { spin: true }; fan2.userData = { spin: true };
                }
                else if (beat.type === "TIMELINE") {
                    const branchA = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.5, 6), new THREE.MeshBasicMaterial({ color: 0x442200 })); branchA.rotation.z = 0.5;
                    const branchB = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.5, 6), new THREE.MeshBasicMaterial({ color: 0x00ff00, emissive: 0x00aa00 })); branchB.rotation.z = -0.5;
                    content.add(branchA, branchB);
                    content.position.y = 3;
                }
                else if (beat.type === "BUTTON") {
                    const base = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
                    const btn = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.5), new THREE.MeshStandardMaterial({ color: 0xff9900 }));
                    btn.position.y = 0.5;
                    content.add(base, btn);
                    content.position.y = 0.5;
                }

                group.add(content);
                scene.add(group);
                EXHIBITS.push({ group, type: beat.type, z: zPos });
            });
        }
        createExhibits();

        // --- 4. LOGIC ---
        let targetZ = 0;

        function nextBeat() {
            if (currentBeat < ACT_DATA.length - 1) {
                currentBeat++;
                const beat = ACT_DATA[currentBeat];

                document.getElementById('beat-title').innerText = beat.title;
                document.getElementById('beat-desc').innerText = beat.desc;
                document.getElementById('status-ind').innerText = `BEAT ${currentBeat + 1}/${ACT_DATA.length}`;

                targetZ = (currentBeat + 1) * BEAT_SPACING - 20;

                // Update Spotlight Target
                if (focusSpot && EXHIBITS[currentBeat]) {
                    focusSpot.target.position.copy(EXHIBITS[currentBeat].group.position);
                }

                if (beat.type === "SHUTDOWN") {
                    scene.background = new THREE.Color(0x000000);
                    scene.fog.color.setHex(0x000000);
                    spotLight.intensity = 0;
                    focusSpot.intensity = 0;
                } else {
                    scene.background = new THREE.Color(0x050505);
                    scene.fog.color.setHex(0x050505);
                    spotLight.intensity = 1;
                    focusSpot.intensity = 2;
                }
            } else {
                document.getElementById('beat-title').innerText = "ACT TWO COMPLETE";
                document.getElementById('beat-desc').innerText = "Approaching Chapter 7...";
            }
        }

        // --- ENO AUDIO ENGINE ---
        class EnoEngine {
            constructor() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();

                    this.master = this.ctx.createGain();
                    this.master.gain.value = 0.4;
                    this.master.connect(this.ctx.destination);

                    // 1. CARRIER (The Train Hull)
                    this.carrier = this.ctx.createOscillator();
                    this.carrier.type = 'sine';
                    this.carrier.frequency.value = 60;
                    this.carrierGain = this.ctx.createGain();
                    this.carrierGain.gain.value = 0;
                    this.carrier.connect(this.carrierGain).connect(this.master);
                    this.carrier.start();

                    // 2. TEXTURE (The Spark)
                    this.texture = this.ctx.createOscillator();
                    this.texture.type = 'triangle';
                    this.texture.frequency.value = 120;
                    this.textureFilter = this.ctx.createBiquadFilter();
                    this.textureFilter.type = 'lowpass';
                    this.textureFilter.frequency.value = 400;
                    this.textureGain = this.ctx.createGain();
                    this.textureGain.gain.value = 0;

                    this.texture.connect(this.textureFilter).connect(this.textureGain).connect(this.master);
                    this.texture.start();

                } catch (e) {
                    console.warn("Audio Context Failed", e);
                }
            }

            update(speed, currentBeatType) {
                if (!this.ctx) return;
                const now = this.ctx.currentTime;

                // MAPPING 1: Speed -> Carrier
                const targetFreq = 50 + (speed * 20);
                this.carrier.frequency.setTargetAtTime(targetFreq, now, 0.1);
                const targetVol = Math.min(speed * 0.5, 0.6);
                this.carrierGain.gain.setTargetAtTime(targetVol, now, 0.2);

                // MAPPING 2: Beat Type -> Texture
                if (speed < 1.0) {
                    let harmonic = 2;
                    if (currentBeatType === "SHUTDOWN") harmonic = 0.5; // Sub-bass
                    if (currentBeatType === "STRAIN") harmonic = 1.33; // Tension
                    if (currentBeatType === "PROMISE") harmonic = 3; // Fifth

                    this.texture.frequency.setTargetAtTime(targetFreq * harmonic, now, 0.5);
                    this.textureGain.gain.setTargetAtTime(0.1, now, 1.0);
                    this.textureFilter.frequency.setTargetAtTime(1200, now, 2.0);
                } else {
                    this.textureGain.gain.setTargetAtTime(0, now, 0.1);
                    this.textureFilter.frequency.setTargetAtTime(100, now, 0.1);
                }
            }

            triggerStationID(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain).connect(this.master);

                // Sound Palette Ch6
                if (type === "SHUTDOWN") {
                    // "POWER DOWN" - Pitch Drop
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.5);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.5, t + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
                    osc.start(t);
                    osc.stop(t + 0.7);
                } else if (type === "PROMISE" || type === "TIMELINE") {
                    // "GLISTEN" - High Sine
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc.start(t);
                    osc.stop(t + 0.4);
                } else if (type === "MODS" || type === "QUEUE") {
                    // "DATA CLICK" - Short Square
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.1, t + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                    osc.start(t);
                    osc.stop(t + 0.1);
                } else {
                    // Generic
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(300, t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.2, t + 0.02);
                    gain.gain.linearRampToValueAtTime(0, t + 0.3);
                    osc.start(t);
                    osc.stop(t + 0.4);
                }
            }
        }

        const audio = new EnoEngine();

        // --- 5. LOOP ---
        let hasArrived = true;

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);

            const dist = targetZ - TRAIN_GROUP.position.z;
            let currentSpeed = 0;
            if (Math.abs(dist) > 0.5) {
                currentSpeed = Math.max(0.1, dist * 0.05);
                TRAIN_GROUP.position.z += currentSpeed;
                hasArrived = false;
            } else {
                if (!hasArrived) {
                    hasArrived = true;
                    // ARRIVAL EVENT
                    const beat = ACT_DATA[currentBeat];
                    audio.triggerStationID(beat ? beat.type : 'NONE');
                }
            }

            // Audio Link
            const targetBeat = ACT_DATA[currentBeat];
            audio.update(currentSpeed, targetBeat ? targetBeat.type : 'NONE');

            EXHIBITS.forEach(ex => {
                ex.group.rotation.y += 0.005;
                // Spin fans
                ex.group.traverse(obj => {
                    if (obj.userData && obj.userData.spin) obj.rotation.y += 0.5;
                });
            });

            leftRail.position.z = TRAIN_GROUP.position.z + 500;
            rightRail.position.z = TRAIN_GROUP.position.z + 500;
            grid.position.z = TRAIN_GROUP.position.z;

            renderer.render(scene, camera);
        }
        animate();

        document.getElementById('btn-next').addEventListener('click', nextBeat);
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') nextBeat(); });

        nextBeat();

    </script>
</body>

</html>